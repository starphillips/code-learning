
This is like pointers?

![[code-example-5.png]]

In this example, we do not want `calculate_length` to take ownership of the variable.

Instead, we use referencing (`&String` and `&s1`) so that it makes a reference to the variable. The function and s will borrow the value of s1.

Referencing does not take ownership of the variable

Even when s is dropped at the the `calculate_length` function, it is still available because it is referenced.

References are immutable by default


##### Making references mutable

![[code-example-8.png]]
To make the reference mutable: we must make the variable mutable (`mut`), and then the args `&mut` which is a mutable reference.



Limitation: you can only have one mutable reference to the string in the same scope. This can prevent errors at runtime and corrupt data. 

Corrupt data can be made as one reference may try to write to the same value as the other reference is reading it.

Example:

![[code-example-7.png]]




You can have multiple immutable references.

Here you have two immutable references. 
Then later on we have a mutable reference using the same variable.
As r1 and r2 are now out of scope, r3 can safely be mutable as r1 and 2 are not going to be used. 

![[code-example-12.png]]


OVERVIEW:

1. At any given time, you can have one mutable reference and any number of immutable references
2. References must point to valid data