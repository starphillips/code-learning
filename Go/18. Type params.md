Type parameters let your functions work with multiple types.
Constraints (like comparable) restrict what types are allowed.
They let you write generic functions or types in Go that work with different types without duplicating code.

``` go
package main

import "fmt"

func Index[T comparable](s []T, x T) int

//Layout
function[Type constraint](slice of type, single value of T) return type
```

T - placeholder for a type
comparable - constraint that says T must support `==` and `!=` (Without this, Go wouldn't allow == on arbitrary types)
`s []T` - slice value of type T
`x T` - single value of type T 
`int` - return type


Why do we need comparable?
With generics, Go doesn't know the exact type, unless told.
It doesn’t know whether to compare values of T unless it says explicitly ‘constrain T to types were comparison is valid’.

Constraints
Comparable – allows use of `==`, `!=`
Any – allows any type, no constraints. (Alias for interfaces)

