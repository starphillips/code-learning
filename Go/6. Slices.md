
Abstraction of arrays - no fixed element

`[]string`  a slice of strings

``` go
	c := []int{1, 2, 3} // [1,2,3]

	c = append(c, 12) // can then append

	fmt.Println(c)
```

**Fixed Slice**
``` go
package main

import (
	"fmt"
	"strings"
)

func main() {
	primes := [6]int{2, 3, 5, 7, 11, 13}

	var s []int = primes[1:4]
	fmt.Println(s) // Prints the indexes 1-3 out of the primes array. So up to the 4th max
	
```


``` go
	names := [4]string{
		"John",
		"Paul",
		"George",
		"Ringo",
	}
	fmt.Println(names) // [John Paul George Ringo]

	a := names[0:2]
	b := names[1:3]
	fmt.Println(a, b) // [John Paul] [Paul George]

	b[0] = "XXX"
	fmt.Println(a, b) // [John XXX] [XXX George]
	
	fmt.Println(names) // [John XXX George Ringo]
	
```

b is XXX George because b starts at `names[1]`. whilst its not at the start of `names[1]`, is it still also just starting its own array (at index 0) so `b[0]` is `names[1]` (Paul)

Now with `a` it is John XXX because whilst a starts at the same index of names, `a[0]` and `b[1]` are looking for the same spot in memory inside the original array. As they overlap this changes it for a too

Slices don’t copy data — they point to the same underlying array.


**Slices of Slices**
`[][]strings`  a slice of `[]string`(a collection of rows)

``` go
	// Two [] means you are creating a 2D slice
	board := [][]string{ 
		[]string{"_", "_", "_"},
		[]string{"_", "_", "_"},
		[]string{"_", "_", "_"},
	}

	// Rows and then Columns
	board[0][0] = "X"
	board[2][2] = "O"
	board[1][2] = "X"
	board[1][0] = "O"
	board[0][2] = "X"

	for i := 0; i < len(board); i++ {
		fmt.Printf("%s\n", strings.Join(board[i], " "))
	}

}

```