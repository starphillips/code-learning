**Interfaces** = set of method signatures.

If a type has all the methods that an interface needs, it’ll automatically implement the interface. 

Interfaces can be thought of as a tuple of a value and concrete type as it stores value, type.

Except when it comes to nil interfaces which holds neither value or type.

This interface says 'I don't care what shape you are, if you can tell me your Area, you're a shape
``` go
type Shape interface {
	Area() float64
}

type Circle struct {
	Radius float64
}

func (c Circle) Area() float64 {
	return math.Pi * c.Radius * c.Radius
}

type Rectangle struct {
	Width, Height float64
}

func (r Rectangle) Area() float64 {
	return r.Width * r.Height
}

// Here both circle and rectangle will implement the interface because they provide their area

func PrintArea(s Shape) {
	fmt.Println("Area:", s.Area())
}

// Here print area takes in Shape and Shape can accept both Circle and Rectangle

func main() {
	c := Circle{Radius: 5}
	r := Rectangle{Width: 4, Height: 3}

	PrintArea(c) // Area of circle
	PrintArea(r) // Area of rectangle
}
```

Another example
``` go
type I interface {
	M()
}

type T struct {
	S string
}

// This method means type T implements the interface I, because interface has M()
// but we don't need to explicitly declare that it does

func (t T) M() { // T takes in M so it automatically uses the interface
	fmt.Println(t.S)
}

func main() {
	var i I = T{"hello"}
	i.M()
}
```

**NIL RECEIVER**
**Nil receiver** = If the concrete value inside the interface itself is nil, the method will be called with a nil receiver.

Beneficial as it doesn’t cause the programme to crash. 

``` go
type Person struct {
	Name string
}

func (p *Person) Greet() {
	if p == nil {
		fmt.Println("No one to greet.")
		return
	}
	fmt.Println("Hello,", p.Name)
}

func main() {
	var p *Person = nil
	p.Greet() // Will not crash
}

```

**NIL RECEIVER 2**
``` go
type I interface {
	M()
}

func main() {
	var i I // A nil interface
	describe(i)
	i.M() // You cannot call on a nil interface because there is no type to indicate which concrete method to call
}

func describe(i I) {
	fmt.Printf("(%v, %T)\n", i, i)
}
```


**EMPTY INTERFACE**
The interface type that specifies zero methods is known as the empty interface.

Empty interfaces are used by code that handles values of unknown type. For example, `fmt.Print` takes any number of arguments of `type interface{}`.

``` go
func main() {
	var i interface{} // empty interface
	describe(i)

	i = 42
	describe(i)

	i = "hello"
	describe(i)
}

func describe(i interface{}) {
	fmt.Printf("(%v, %T)\n", i, i)
}
```
